package Chapter2

/**
  * # 2 Expressions, Types, and Values
  * この章では、Scalaプログラムの基本的な構成要素である「式」「型」「値」について説明します。
  * これらの概念を理解することは、Scalaのプログラムがどのように動作するかというメンタルモデルを構築するために必要です。
  */
object chapter21 {

  /**
    * ## 2.1 Your First Program
    * Scalaのコンソールまたはワークシートで "Hello world!"と入力し，リターンキー（コンソール）を押すか，ワークシートを保存します。このような画面が表示されるはずです。
    */
  "Hello world!"
  // res0: String = Hello world!

  /**
    * このプログラムについては、言いたいことがたくさんあります。
    * このプログラムは一つの式で構成されており，特にリテラル式（略してリテラル）で構成されています．
    *
    * Scalaはこのプログラムを実行、つまり評価します。Scalaのコンソールやワークシートでプログラムを評価すると，2つの情報が得られます：プログラムの型と評価値です。
    * この例では，型はStringで，値は "Hello world!"
    *
    * "Hello world!"という出力値は、それを作ったプログラムと同じように見えますが、両者には違いがあります。
    * リテラル式は、私たちが入力したプログラムの文字列であり、コンソールが出力するのは、そのプログラムを評価した結果なのです。(リテラルは、評価したものが文字通りの形をしているので、このような名前がついています)。
    *
    * もう少し複雑なプログラムを見てみましょう。
    */
  "Hello world!".toUpperCase
  // res1: String = HELLO WORLD!

  /**
    * このプログラムは，最初の例にメソッド呼び出しを加えて拡張したものです．
    * Scalaの評価は，左から右へと進みます．最初の例のように，まず "Hello world!"というリテラルが評価されます．
    * 次に，その結果に対してメソッド toUpperCase が呼び出されます．
    * このメソッドは、文字列の値を大文字に変換し、その新しい文字列を返します。これが、コンソールに表示される最終的な値です。
    *
    * このプログラムの型は再び String ですが、この場合は "HELLO WORLD!" と評価されます。
    */
  object chapter211 {

    /**
      * ### 2.1.1 Compile-time and Run-time
      * Scalaのプログラムには2つの段階があります。まずコンパイルされ、コンパイルに成功すると実行または評価されます。
      * 最初の段階をコンパイル時、後の段階をランタイムと呼んでいます。
      *
      * Scalaのコンソールを使っていると、プログラムはコンパイルされるとすぐに評価されるので、1つのステージしかないように見えます。
      * 型と値の違いを正しく理解するためには、コンパイル時と実行時が別物であることを理解することが重要です。
      *
      * コンパイルとは、プログラムが意味を持っているかどうかを確認する作業です。
      * プログラムが意味をなすためには、2つの方法があります。
      *
      * 1. プログラムの各部分が言語の文法に沿って配置されていること、つまり構文的に正しいことです。統語的に正しくない英文の例は、"on cat mat sat the "です。また、構文的に正しくないScalaプログラムの例は
      */
//    toUpperCase."Hello world!"
//    // <console>:2: error: identifier expected but string literal found.
//    // toUpperCase."Hello world!"
//    //             ^

    /**
      * 2. 型チェックをしなければなりません。つまり、意味のあるプログラムとは何かという、ある種の制約に従わなければなりません。構文的には正しいが、意味を成していない英文の例としては、"the mat sat on the cat "があります。型チェックに失敗する簡単なプログラムは、数字を大文字に変換することです。
      */
//    2.toUpperCase
//    // <console>:13: error: value toUpperCase is not a member of Int
//    //        2.toUpperCase
//    //          ^

    /**
      * 大文字と小文字の概念は数字には意味がなく、型システムはこのエラーを検出します。
      * コンパイル時のチェックに合格したプログラムは、次に実行することができます。
      * これは、コンピュータがプログラムの命令を実行するプロセスです。
      * プログラムのコンパイルに成功しても、実行時に失敗することがあります。整数をゼロで割ると、Scalaではランタイムエラーが発生します。
      */
//    2 / 0
//    // java.lang.ArithmeticException: / by zero
//    //   ... 362 elided

    /**
    * 整数の型であるIntは除算が可能なので、プログラムの型をチェックします。
    * 実行時には、除算の結果を表すIntが存在しないため、プログラムは失敗します。
    */
  }

  object chapter212 {

    /**
      * ### 2.1.2 Expressions, Types, and Values
      * では、「式」「型」「値」とは一体何なのでしょうか？
      *
      * 式とは、プログラムのテキストの一部で、ファイルやコンソール、ワークシートに入力されるものです。
      * Scalaのプログラムを構成する主要な要素です。
      * 他の構成要素である定義や文については、後ほど説明します。式はコンパイル時に存在します。
      *
      * 式の決定的な特徴は、値に評価されることです。
      * 値とは、コンピュータのメモリに格納されている情報です。値は実行時に存在します。
      * 例えば、2という式は、コンピュータのメモリ内の特定の場所にある特定のビット列として評価されます。
      *
      * 私たちは値を使って計算します。
      * 値は、プログラムが受け渡しや操作を行うことができる実体です。例えば、2つの数字の最小値を計算するには、次のようなプログラムを書きます。
      */
    2.min(3)
    // res4: Int = 2

    /**
      * ここでは，2と3という2つの値があり，それらを組み合わせて，2と評価されるより大きなプログラムにしています．
      * Scalaでは、すべての値はオブジェクトであり、これには特別な意味があることを後で説明します。
      * さて，次に型について説明します．型とは、オブジェクトの操作方法を制限するプログラムの制約です。
      * すでに、StringとIntという2つの型を見て、型によって異なる操作ができることを見てきました。
      *
      * この段階で、型についての最も重要なポイントは、「式には型があるが、値には型がない」ということです。
      * コンピュータのメモリの任意の部分を検査し、それを作成したプログラムを知らずに、それをどのように解釈するかを決めることはできません。
      * 例えば、ScalaではInt型とFloat型はどちらも32ビットのメモリで表現されています。
      * ある32ビットがInt型とFloat型のどちらに解釈されるべきかを示すタグなどはありません。
      *
      * 型がコンパイル時に存在することは、ランタイムエラーを引き起こす式の型をScalaコンソールに教えてもらうことで示すことができます。
      */
//      :type 2 / 0
//    // Int

//    2 / 0
//    // java.lang.ArithmeticException: / by zero
//    //   ... 506 elided

    /**
      * 型はコンパイル時に存在するもので、値に一貫した解釈を与えるプログラムを書くことを制限します。
      * ある32ビットの値が，ある時点ではInt型であり，別の時点ではFloat型であると主張することはできません．
      * プログラムが型チェックを行う際、Scalaはすべての値が一貫して使用されることを保証するため、値の表現に型情報を記録する必要はありません。
      * このように型情報を削除することを型消去といいます1。
      */

    /**
      * - 型消去
      * これは完全に真実ではありません。
      * Scalaのコードを実行するプログラムであるJava仮想マシンは、2種類のオブジェクトを区別しています。
      * プリミティブ型は、表現する値とともに型情報を格納しません。
      * オブジェクト型は型情報を格納します。
      * しかし、この型情報は完全ではなく、失われてしまうこともあります。
      * このように、コンパイル時と実行時の区別を曖昧にすることは危険です。
      * 実行時に型情報が存在することに依存しなければ（これから紹介するパターンはそうではありません）、このような問題に遭遇することはありません。
      */

    /**
    * 型は必然的に、その型に適合する値についての可能な限りの情報を含んでいません。
    * もしそうであれば、型検査はプログラムを実行することと同じになってしまいます。
    * Intを0で割るとランタイムエラーになることを，型システムが防げないことはすでに見たとおりです．
    *
    * Scalaのコードを設計する上で重要なことは，型システムを使ってどのようなエラーケースを排除したいかを決めることです．
    * 型システムでは，プログラムの信頼性を向上させる多くの有用な制約を表現できることがわかります．
    * プログラムの中で十分に重要であると判断した場合には，エラーの可能性を表現するために型システムを使用する除算演算子を実装することができます．
    * 型システムを上手に使うことが、この本のメインテーマの1つです。
    */
  }

  object chapter213 {

    /**
    * ### 2.1.3 Take Home Points
    * Scalaを使うためには、Scalaプログラムのメンタルモデルを構築する必要があります。
    * このモデルを構成する基本的な要素は、式、型、値の3つです。
    *
    * 式とは、プログラムの中で値として評価される部分のことです。
    * これはScalaプログラムの主要な部分です。
    *
    * 式には型があり、これはプログラムに対する何らかの制限を表しています。
    * コンパイル時には、プログラムの型がチェックされます。
    * 型が一致しない場合、コンパイルは失敗し、プログラムを評価、実行することはできません。
    *
    * 値はコンピュータのメモリ上に存在し、実行中のプログラムが操作するものです。
    * Scalaではすべての値はオブジェクトであり、その意味については後で説明します。
    */
  }

  object chapter214 {

    /**
      *Scalaのコンソールまたはワークシートを使って、次の式の型と値を決定します。
      */
    1 + 2
    // Int = 3

    "3".toInt
    // Int = 3

    "foo".toInt
    // error: value toInt is not a member of String

    /**
      * 模範
      */
    /**
      * * タイプはInt、値は3です。
      *
      * * タイプはInt、値は3です。
      *
      * 型はIntですが、これは値として評価されません。
      * 代わりに例外が発生し、発生した例外は値ではありません。これをどうやって見分けるのでしょうか？
      * この式の結果を使って計算を続けることはできません。例えば、printすることはできません。比較
      */
    println("foo")
    // foo

    /**
      * そして
      */
    println("foo".toInt)
    // java.lang.NumberFormatException: For input string: "foo"
    //   at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
    //   at java.lang.Integer.parseInt(Integer.java:580)
    //   at java.lang.Integer.parseInt(Integer.java:615)
    //   at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:272)
    //   at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
    //   ... 750 elided
  }

  def main(args: Array[String]): Unit = {
    println("chapter21")
  }
}
