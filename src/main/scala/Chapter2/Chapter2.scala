package Chapter2

/**
  * # 2 Expressions, Types, and Values
  * この章では、Scalaプログラムの基本的な構成要素である「式」「型」「値」について説明します。
  * これらの概念を理解することは、Scalaのプログラムがどのように動作するかというメンタルモデルを構築するために必要です。
  */
object chapter21 {

  /**
    * ## 2.1 Your First Program
    * Scalaのコンソールまたはワークシートで "Hello world!"と入力し，リターンキー（コンソール）を押すか，ワークシートを保存します。このような画面が表示されるはずです。
    */
  "Hello world!"
  // res0: String = Hello world!

  /**
    * このプログラムについては、言いたいことがたくさんあります。
    * このプログラムは一つの式で構成されており，特にリテラル式（略してリテラル）で構成されています．
    *
    * Scalaはこのプログラムを実行、つまり評価します。Scalaのコンソールやワークシートでプログラムを評価すると，2つの情報が得られます：プログラムの型と評価値です。
    * この例では，型はStringで，値は "Hello world!"
    *
    * "Hello world!"という出力値は、それを作ったプログラムと同じように見えますが、両者には違いがあります。
    * リテラル式は、私たちが入力したプログラムの文字列であり、コンソールが出力するのは、そのプログラムを評価した結果なのです。(リテラルは、評価したものが文字通りの形をしているので、このような名前がついています)。
    *
    * もう少し複雑なプログラムを見てみましょう。
    */
  "Hello world!".toUpperCase
  // res1: String = HELLO WORLD!

  /**
    * このプログラムは，最初の例にメソッド呼び出しを加えて拡張したものです．
    * Scalaの評価は，左から右へと進みます．最初の例のように，まず "Hello world!"というリテラルが評価されます．
    * 次に，その結果に対してメソッド toUpperCase が呼び出されます．
    * このメソッドは、文字列の値を大文字に変換し、その新しい文字列を返します。これが、コンソールに表示される最終的な値です。
    *
    * このプログラムの型は再び String ですが、この場合は "HELLO WORLD!" と評価されます。
    */
  object chapter211 {

    /**
      * ### 2.1.1 Compile-time and Run-time
      * Scalaのプログラムには2つの段階があります。まずコンパイルされ、コンパイルに成功すると実行または評価されます。
      * 最初の段階をコンパイル時、後の段階をランタイムと呼んでいます。
      *
      * Scalaのコンソールを使っていると、プログラムはコンパイルされるとすぐに評価されるので、1つのステージしかないように見えます。
      * 型と値の違いを正しく理解するためには、コンパイル時と実行時が別物であることを理解することが重要です。
      *
      * コンパイルとは、プログラムが意味を持っているかどうかを確認する作業です。
      * プログラムが意味をなすためには、2つの方法があります。
      *
      * 1. プログラムの各部分が言語の文法に沿って配置されていること、つまり構文的に正しいことです。統語的に正しくない英文の例は、"on cat mat sat the "です。また、構文的に正しくないScalaプログラムの例は
      */
//    toUpperCase."Hello world!"
//    // <console>:2: error: identifier expected but string literal found.
//    // toUpperCase."Hello world!"
//    //             ^

    /**
      * 2. 型チェックをしなければなりません。つまり、意味のあるプログラムとは何かという、ある種の制約に従わなければなりません。構文的には正しいが、意味を成していない英文の例としては、"the mat sat on the cat "があります。型チェックに失敗する簡単なプログラムは、数字を大文字に変換することです。
      */
//    2.toUpperCase
//    // <console>:13: error: value toUpperCase is not a member of Int
//    //        2.toUpperCase
//    //          ^

    /**
      * 大文字と小文字の概念は数字には意味がなく、型システムはこのエラーを検出します。
      * コンパイル時のチェックに合格したプログラムは、次に実行することができます。
      * これは、コンピュータがプログラムの命令を実行するプロセスです。
      * プログラムのコンパイルに成功しても、実行時に失敗することがあります。整数をゼロで割ると、Scalaではランタイムエラーが発生します。
      */
//    2 / 0
//    // java.lang.ArithmeticException: / by zero
//    //   ... 362 elided

    /**
    * 整数の型であるIntは除算が可能なので、プログラムの型をチェックします。
    * 実行時には、除算の結果を表すIntが存在しないため、プログラムは失敗します。
    */
  }

  object chapter212 {

    /**
      * ### 2.1.2 Expressions, Types, and Values
      * では、「式」「型」「値」とは一体何なのでしょうか？
      *
      * 式とは、プログラムのテキストの一部で、ファイルやコンソール、ワークシートに入力されるものです。
      * Scalaのプログラムを構成する主要な要素です。
      * 他の構成要素である定義や文については、後ほど説明します。式はコンパイル時に存在します。
      *
      * 式の決定的な特徴は、値に評価されることです。
      * 値とは、コンピュータのメモリに格納されている情報です。値は実行時に存在します。
      * 例えば、2という式は、コンピュータのメモリ内の特定の場所にある特定のビット列として評価されます。
      *
      * 私たちは値を使って計算します。
      * 値は、プログラムが受け渡しや操作を行うことができる実体です。例えば、2つの数字の最小値を計算するには、次のようなプログラムを書きます。
      */
    2.min(3)
    // res4: Int = 2

    /**
      * ここでは，2と3という2つの値があり，それらを組み合わせて，2と評価されるより大きなプログラムにしています．
      * Scalaでは、すべての値はオブジェクトであり、これには特別な意味があることを後で説明します。
      * さて，次に型について説明します．型とは、オブジェクトの操作方法を制限するプログラムの制約です。
      * すでに、StringとIntという2つの型を見て、型によって異なる操作ができることを見てきました。
      *
      * この段階で、型についての最も重要なポイントは、「式には型があるが、値には型がない」ということです。
      * コンピュータのメモリの任意の部分を検査し、それを作成したプログラムを知らずに、それをどのように解釈するかを決めることはできません。
      * 例えば、ScalaではInt型とFloat型はどちらも32ビットのメモリで表現されています。
      * ある32ビットがInt型とFloat型のどちらに解釈されるべきかを示すタグなどはありません。
      *
      * 型がコンパイル時に存在することは、ランタイムエラーを引き起こす式の型をScalaコンソールに教えてもらうことで示すことができます。
      */
//      :type 2 / 0
//    // Int

//    2 / 0
//    // java.lang.ArithmeticException: / by zero
//    //   ... 506 elided

    /**
      * 型はコンパイル時に存在するもので、値に一貫した解釈を与えるプログラムを書くことを制限します。
      * ある32ビットの値が，ある時点ではInt型であり，別の時点ではFloat型であると主張することはできません．
      * プログラムが型チェックを行う際、Scalaはすべての値が一貫して使用されることを保証するため、値の表現に型情報を記録する必要はありません。
      * このように型情報を削除することを型消去といいます1。
      */

    /**
      * - 型消去
      * これは完全に真実ではありません。
      * Scalaのコードを実行するプログラムであるJava仮想マシンは、2種類のオブジェクトを区別しています。
      * プリミティブ型は、表現する値とともに型情報を格納しません。
      * オブジェクト型は型情報を格納します。
      * しかし、この型情報は完全ではなく、失われてしまうこともあります。
      * このように、コンパイル時と実行時の区別を曖昧にすることは危険です。
      * 実行時に型情報が存在することに依存しなければ（これから紹介するパターンはそうではありません）、このような問題に遭遇することはありません。
      */

    /**
    * 型は必然的に、その型に適合する値についての可能な限りの情報を含んでいません。
    * もしそうであれば、型検査はプログラムを実行することと同じになってしまいます。
    * Intを0で割るとランタイムエラーになることを，型システムが防げないことはすでに見たとおりです．
    *
    * Scalaのコードを設計する上で重要なことは，型システムを使ってどのようなエラーケースを排除したいかを決めることです．
    * 型システムでは，プログラムの信頼性を向上させる多くの有用な制約を表現できることがわかります．
    * プログラムの中で十分に重要であると判断した場合には，エラーの可能性を表現するために型システムを使用する除算演算子を実装することができます．
    * 型システムを上手に使うことが、この本のメインテーマの1つです。
    */
  }

  object chapter213 {

    /**
    * ### 2.1.3 Take Home Points
    * Scalaを使うためには、Scalaプログラムのメンタルモデルを構築する必要があります。
    * このモデルを構成する基本的な要素は、式、型、値の3つです。
    *
    * 式とは、プログラムの中で値として評価される部分のことです。
    * これはScalaプログラムの主要な部分です。
    *
    * 式には型があり、これはプログラムに対する何らかの制限を表しています。
    * コンパイル時には、プログラムの型がチェックされます。
    * 型が一致しない場合、コンパイルは失敗し、プログラムを評価、実行することはできません。
    *
    * 値はコンピュータのメモリ上に存在し、実行中のプログラムが操作するものです。
    * Scalaではすべての値はオブジェクトであり、その意味については後で説明します。
    */
  }

  object chapter214 {

    /**
      * Exercises
      * Scalaのコンソールまたはワークシートを使って、次の式の型と値を決定します。
      */
    1 + 2
    // Int = 3

    "3".toInt
    // Int = 3

    "foo".toInt
    // error: value toInt is not a member of String

    /**
      * 模範
      */
    /**
      * * タイプはInt、値は3です。
      *
      * * タイプはInt、値は3です。
      *
      * 型はIntですが、これは値として評価されません。
      * 代わりに例外が発生し、発生した例外は値ではありません。これをどうやって見分けるのでしょうか？
      * この式の結果を使って計算を続けることはできません。例えば、printすることはできません。比較
      */
    println("foo")
    // foo

    /**
      * そして
      */
    println("foo".toInt)
    // java.lang.NumberFormatException: For input string: "foo"
    //   at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
    //   at java.lang.Integer.parseInt(Integer.java:580)
    //   at java.lang.Integer.parseInt(Integer.java:615)
    //   at scala.collection.immutable.StringLike$class.toInt(StringLike.scala:272)
    //   at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)
    //   ... 750 elided
  }

  def main(args: Array[String]): Unit = {
    println("chapter21")
  }
}

object chapter22 {

  /**
    * ## 2.2 Interacting with Objects
    * 前節では、Scalaプログラムの基本的な構成要素である、式、型、値について説明しました。
    * すべての値はオブジェクトであることを学びました。
    * このセクションでは、オブジェクトについて、また、どのようにしてオブジェクトを操作するのかについて学びます。
    */
  /**
    * ### 2.2.1 Objects
    * オブジェクトとは、データとそのデータに対する操作をまとめたものです。
    * 例えば、2はオブジェクトです。データは整数の2であり、そのデータに対する演算は、＋、-などのおなじみの演算です。
    *
    * オブジェクトのデータと操作には、いくつかの特別な用語があります。
    * 操作はメソッドとして知られています。データはフィールドに格納されています。
    */
  object chapter222 {

    /**
      * ### 2.2.2 Method Calls
      * オブジェクトを操作するには、メソッドを呼び出す必要があります※2。
      *
      * - ※2
      * オブジェクトを操作する方法には、パターンマッチングと呼ばれる方法もあります。パターン・マッチングについては後ほどご紹介します。
      *
      * メソッドの呼び出しの例をいくつか見てきました。例えば、StringのtoUpperCaseメソッドを呼び出すことで、Stringの大文字バージョンを取得することができます。
      */
    "hello".toUpperCase
    // res0: String = HELLO

    /**
      * メソッドの中には、メソッドの動作を制御するパラメータや引数を受け付けるものがあります。
      * たとえば、take メソッドは、String から文字を取得します。
      * takeにパラメータを渡して、必要な文字数を指定する必要があります。
      */
    "abcdef".take(3)
    // res1: String = abc

    "abcdef".take(2)
    // res2: String = ab

    /**
      * ***
      * **Method Call Syntax**
      * メソッドコールの構文は以下の通りです。
      */
//    anExpression.methodName(param1, ...)

    /**
      * or
      */
//    anExpression.methodName

    /**
      * where
      * * anExpression は，任意の式（オブジェクトとして評価される）です。
      * * methodName は、メソッドの名前です。
      * * オプションの param1, ... は、メソッドのパラメータとして評価される 1 つまたは複数の式です。
      * ***
      */
    /**
      * メソッドコールは式なので、オブジェクトとして評価されます。
      * つまり、メソッドコールを連鎖させて、より複雑なプログラムを作ることができるのです。
      */
    "hello".toUpperCase.toLowerCase
    // res3: String = hello

    /**
      * メソッドコール内の様々な式はどのような順序で評価されますか？
      * メソッドのパラメーターは、メソッドが呼び出される前に、左から右へと評価されます。そのため、以下の式では
      */
    "Hello world!".take(2 + 3)
    // res4: String = Hello

    /**
    * 式 "Hello world!"が最初に評価され、次に2 + 3 (これには2と3を最初に評価する必要があります)、最後に "Hello world!".take(5)が評価されます。
    */
  }

  object chapter223 {

    /**
      * ### 2.2.3 Operators
      * Scalaではすべての値がオブジェクトなので、IntやBooleanなどのプリミティブな型のメソッドを呼び出すこともできます。
      * これは、intやbooleanがオブジェクトではないJavaとは対照的です。
      */
    123.toShort // this is how we define a `Short` in Scala
    // res5: Short = 123

    123.toByte // this is how we define a `Byte`
    // res6: Byte = 123

    /**
      * しかし、Intがオブジェクトであるならば、+や-といった数学の基本的な演算子は何でしょうか？
      * それらもメソッドなのでしょうか？はい，Scalaのメソッドには，英数字だけでなく，記号的な名前も付けられます。
      */
    43 - 3 + 2
    // res7: Int = 42

    43.-(3).+(2)
    // res8: Int = 42

    /**
      * (なお、Scala 2.10以前では、43.がDoubleと解釈されるのを防ぐために、(43).-(3).+(2)と書かなければなりません)。
      */
    /**
      * ***
      * **演算子の表記法**
      * a.b(c)と書かれたScalaの式は、a b cとも書くことができます。
      * a b c d eはa.b(c).d(e)と同じで、a.b(c, d, e)ではないことに注意してください。
      * ***
      */
    /**
      * パラメータを1つ取るメソッドであれば、記号名や英数字の名前に関わらず、 infix 演算子表記を使用することができます。
      */
    "the quick brown fox" split " "
    // res: Array[String] = Array(the, quick, brown, fox)

    /**
      * infix記法は、冗長なメソッド呼び出しの代わりに単純な演算子式を書くことができる、いくつかの構文上の省略形の1つです。
      * 前置演算子、後置演算子、右結合演算子、代入演算子などの記法もありますが、これらはインフィックス記法よりもはるかに一般的ではありません。
      *
      * では，どのような優先順位規則を infix 演算子に関連付けるべきかという疑問が生じます。
      * Scalaでは、数学や論理学から得られる直感的な理解に基づいて、メソッド名として使用する識別子から得られる一連の優先順位規則を使用しています。
      */
    2 * 3 + 4 * 5
    // res11: Int = 26

    (2 * 3) + (4 * 5)
    // res12: Int = 26

    2 * (3 + 4) * 5
    // res13: Int = 70
  }

  object chapter224 {

    /**
      * ### 2.2.4 Take home points
      * Scalaの値はすべてオブジェクトです。私たちは、オブジェクトのメソッドを呼び出して、オブジェクトと対話します。
      * もしあなたがJavaのバックグラウンドをお持ちなら、Intやその他のプリミティブな値のメソッドを呼び出すことができます。
      *
      * メソッド呼び出しの構文は
      */
//    anExpression.methodName(parameter, ...)

    /**
      * or
      */
//    anExpression methodName parameter

    /**
    * Scalaには演算子がほとんどなく、ほとんどすべてがメソッドコールです。
    * コードをシンプルで読みやすいものにするために、infix 演算子表記のような構文規則を使用していますが、意味のあるところでは常に標準的なメソッド表記に戻ることができます。
    *
    * これから分かるように、Scalaは式を使ったプログラミングに重点を置いているので、Javaよりもずっと短いコードを書くことができます。
    * また、値や型を使って、非常に直感的にコードを推論することができます。
    */
  }

  object chapter225 {
    object chapter2251 {

      /**
        * Exercises
        */
      /**
        * 2.2.5.1 Operator Style
        */
      /**
        * 演算子スタイルで書き換え
        */
      "foo" take 1

      /**
        * メソッドコールスタイルに書き換え
        */
//      1 + 2 + 3
      1.+(2).+(3)

      /**
        * 模範
        */
//      "foo" take 1
//      // res15: String = f
//
//      1.+(2).+(3)
//      // res17: Int = 6
    }

    object chapter2252 {

      /**
        * #### 2.2.5.2 Substitution
        * 次の式の違いは何ですか？類似点は何ですか？
        * 1 + 2 + 3
        * 6
        */
      // 結果が同じ

      /**
        * 模範
        */
      /**
      * これらの式は、同じ結果タイプと戻り値を持っています。
      * しかし、結果を得る方法は異なります。前者は一連の加算によって結果を計算しますが、後者は単なるリテラルです。
      *
      * どちらの式にも副作用はないので、ユーザーの視点では交換可能です。
      * プログラムの意味を変えることなく、1 + 2 + 3と書けるところはどこでも6と書くことができ、
      * その逆も可能です。これを「置換」といい、学校で代数式を簡略化したときの原理を思い出すかもしれません。
      *
      * プログラマーとして、私たちはコードがどのように動作するかのメンタルモデルを構築しなければなりません。
      * 評価の置換モデルは非常にシンプルなモデルで、式を見たときにその結果を置換することができるというものです。
      * 副作用がない場合、置換モデルは常に機能します3。
      *
      * - ※3
      * 副作用とは一体何でしょうか？一つの有効な定義は、置換によって誤った結果をもたらすものです。
      * 副作用がなければ，置換は常に機能するのでしょうか？Scalaの正しいモデルを作るためには，置換を適用する順序を定義しなければならない．いくつかの可能な順序があります．
      * たとえば，置換を左から右に実行するのか，右から左に実行するのか？可能な限り早く置換するのか，値が必要になるまで遅らせるのか)．
      * ほとんどの場合、置換の順序は重要ではありませんが、重要な場合もあります。Scalaは常に左から右へ、そして可能な限り早いタイミングで置換を適用します。
      *
      * 式の各構成要素の型と値がわかっていれば、式全体の型と値もわかります。
      * 関数型プログラミングでは、プログラムを理解しやすくするために、副作用を避けることを目指しています。


      */
    }
  }
  def main(args: Array[String]): Unit = {
    println("chapter22")
    println("foo" take 1)
    println(1.+(2).+(3))
  }
}

object chapter23 {

  /**
    * ## 2.3 Literal Objects
    * これまでに、Scalaの基本的な型をいくつか取り上げてきました。
    * このセクションでは、Scalaのすべてのリテラル式をカバーすることで、その知識を完成させるつもりです。
    * リテラル式は、「それ自体」を表す固定値を表します。以下にその例を示します。
    */
  42
  // res0: Int = 42

  /**
    * REPLでのこのやりとりは、リテラル42が Int 42と評価されることを示しています。
    *
    * リテラルとそれが評価される値を混同しないでください!
    * **リテラル式は、プログラムが実行される前のプログラムテキスト内の表現であり、値は、プログラムが実行された後のコンピュータのメモリ内の表現です。**
    *
    * プログラミングの経験、特にJavaの経験があれば、Scalaのリテラルはよく知っているはずです。
    */
  object chapter231 {

    /**
      * ### 2.3.1 Numbers
      * 数字は、Javaと同じ型があります。
      * 32ビットの整数を表すInt、64ビットの浮動小数点を表すDouble、32ビットの浮動小数点を表すFloat、64ビットの整数を表すLongです。
      */
    42
    // res1: Int = 42

    42.0
    // res2: Double = 42.0

    42.0f
    // res3: Float = 42.0

    42L
    // res4: Long = 42

    /**
    * Scalaには16ビットのShort整数と8ビットのByteもありますが、これらを作成するリテラルな構文はありません。
    * その代わり、toShortやtoByteというメソッドを使って作成します。
    */
  }

  object chapter232 {

    /**
      * ### 2.3.2 Booleans
      * ブール値は、Javaとまったく同じで、真か偽かというものです。
      */
    true
    // res5: Boolean = true

    false
    // res6: Boolean = false
  }

  object chapter233 {

    /**
      * ### 2.3.3 Characters
      * Charsは16ビットのUnicode値で、一重引用符で囲まれた一文字として記述されます。
      */
    'a'
    // res7: Char = a

    /**
    * ***
    *
    * **ScalaとJavaの型階層の比較**
    * ScalaのInt、Double、Float、Long、Short、Byte、Boolen、Charは、頭文字の大文字で書かれていますが、Javaのint、Double、Float、Long、Short、Byte、Boolen、Charと全く同じものを指しています。
    * Scalaでは、これらの型はすべて、メソッドやフィールドを持つオブジェクトのように振る舞います。
    * しかし、コードがコンパイルされると、ScalaのIntはJavaのintと全く同じになります。これにより、2つの言語間の相互運用が容易になります。
    *
    * ***
    */
  }

  object chapter234 {

    /**
      * ### 2.3.4 Strings
      * 文字列は、まさにJavaの文字列であり、同じように記述されています。
      */
    "this is a string"
    // res8: String = this is a string

    "the\nusual\tescape characters apply"
    // res9: String =
    // the
    // usual    escape characters apply
  }

  object chapter235 {

    /**
      * ### 2.3.5 Null
      * NullはJavaと同じですが、使用頻度はそれほど高くありません。Scalaのnullにも独自の型があります。Nullです。
      */
    null
    // res10: Null = null

    /**
    * ***
    *
    * **Scalaでのヌルの使い方**
    * ヌルはJavaコードでは一般的ですが、Scalaでは非常に悪い習慣とされています。
    *
    * Javaでのnullの主な用途は、プログラムの実行時に異なるポイントで値を持ったり持たなかったりするオプション値を実装することです。
    * しかし、nullの値はコンパイラがチェックできないため、NullPointerExceptionsの形でランタイムエラーが発生する可能性があります。
    *
    * 後で説明しますが、Scalaにはコンパイラがチェックするオプション値を定義する手段があります。
    * これにより、nullを使用する必要がなくなり、プログラムの安全性が向上します。
    *
    * ***
    */
  }

  object chapter236 {

    /**
      * ### 2.3.6 Unit
      * ()と書かれたUnitは、Javaのvoidに相当するものです。
      * unitは、printlnを使って標準出力に印刷するような、興味深い値ではないと評価される式の結果です。
      * コンソールではunitは表示されませんが、式の型を尋ねることで、実際にunitがいくつかの式の結果であることがわかります。
      */
//    ()
//
//    :type ()
//    // Unit
//
//    println("something")
//      // something
//
//      :type println("something")
//    // Unit

    /**
    * UnitはScalaの重要な概念です。
    * Scalaの構文構造の多くは、型と値を持つ式です。
    * 有用な値を得られない式のためのプレースホルダーが必要であり、unitはまさにそれを提供します。
    */
  }

  object chapter237 {

    /**
    * ### 2.3.7 Take home points
    * このセクションでは、基本的なデータ型に評価されるリテラル式を見てきました。
    * これらの基本的なデータ型は、同等のものがないUnitを除いて、ほとんどがJavaと同じです。
    *
    * すべてのリテラル式は型を持ち、値として評価されます。
    * これは、より複雑なScalaの式にも当てはまります。
    *
    * 次のセクションでは、独自のオブジェクトリテラルを定義する方法を学びます。
    */
  }

  object chapter238 {

    /**
      * ### 2.3.8 Exercises
      */
    object chapter2381 {

      /**
        * Exercises
        * ### 2.3.8.1 Literally Just Literals
        */
      /**
        * 次のScalaのリテラルの値と型は何ですか？
        42

        true

        123L

        42.0
        */
//      42
//      -> Int: 42
//
//      true
//      -> Boolean: true
//
//      123L
//      -> Long: 123
//
//      42.0
//      -> Dounle: 42.0

      /**
        * 模範
        */
//      42 は Int、true は Boolean です。123L は、Long です。42.0 は Double です。
//      この練習は、Scalaのコンソールやワークシートを使った経験を積むためのものです。
    }

    object chapter2382 {

      /**
        * Exercises
        * 次のリテラルの違いは何ですか？また、それぞれの型と値は何ですか？
        'a'
        "a"
        */
      // charとstring

      /**
        * 模範
        */
      /**
      * 1つ目はリテラルのChar、2つ目はリテラルのStringです。
      */
    }

    object chapter2383 {

      /**
        * Exercises
        * 以下の表現の違いは何ですか？それぞれの型と値は何ですか？
       "Hello world!"
        println("Hello world!")
        */
//      リテラル：String と Hello world!
//      printlntはunitなのかな？

      /**
        * 模範
        */
      /**
      * リテラル式 "Hello world!"は、String値として評価されます。
      * println("Hello world!")という式は、Unitと評価され、副作用としてコンソールに "Hello world!"と表示されます。
      *
      * ここで重要なのは、値を評価するプログラムと、副作用として値を表示するプログラムを区別することです。前者はより大きな式の中で使うことができますが、後者はできません。
      */

    }

    object chapter2384 {

      /**
        * Exercises
        * 次のリテラルの型と値は何ですか？REPLやScalaのワークシートで書いてみて、どうなるか見てみましょう
        * 'Hello world!'
        */
//      scalaFiddleで。
//
//      error: unclosed character literal (or use " not ' for string literal)
//        -> stringに対してシングルクォート使うな
//
//        error: ';' expected but something found.
//      -> セミコロンを期待している
//
//        REPLだと2つ目のエラーは出ない

      /**
        * 模範
        */
//      エラーメッセージが表示されるはずです。開発環境のエラーメッセージをよく読んで慣れてください。
    }
  }
}
